<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">

    <!-- Viewport meta tag is critical to have mobile browsers
         actually report correct screen dimensions -->
    <meta name="viewport"
          content="width=device-width, initial-scale=1, user-scalable=no"/>

    <title>Scaling Demo</title>

    <!-- Remove spacing around page contents, i.e., the game, and make
         the background pink and canvas black for debugging purposes -->
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #ff00ff;
        }

        canvas {
            background-color: #222222;
        }
    </style>
</head>

<body onload="preload();">
<script src="lib/pixi.min.js"></script>

<script>
    var GAME_WIDTH = 800;  // Conceptual dimensions of the game
    var GAME_HEIGHT = 500;

    var renderer;
    var stage;

    var scrollSpeed = {
        mtnFar: 0.125,
        mtnMid: 0.25,
        clouds: 0.30,
        trees: -1,
        grass: 2
    };

    // Background textures
    var sky,
        mtnFar,
        mtnMid,
        ground,
        clouds,
        trees,
        grass;

    var BG_RATE = 50;
    var FG_RATE = 125;

    var lasttime;

    function preload() {
        console.log("Preload")

        createrenderer(); // Create renderer to test which kind in loading,
                          // do preloader animations (not implemented)

        var loader = PIXI.loader;

        if (window.devicePixelRatio >= 2 &&
            renderer instanceof PIXI.WebGLRenderer) {
            // WebGL clause works around an apparent issues with
            // TilingSprites on high-res devices using canvas:
            // https://github.com/pixijs/pixi.js/issues/2083
            loader.add("sky", "assets/img/level/sky@2x.png");
            loader.add("mtnFar", "assets/img/level/mtn-far@2x.png");
            loader.add("mtnMid", "assets/img/level/mtn-mid@2x.png");
            loader.add("ground", "assets/img/level/ground@2x.png");
            loader.add("clouds", "assets/img/level/clouds@2x.png");
            loader.add("trees", "assets/img/level/trees@2x.png");
            loader.add("grass", "assets/img/level/grass@2x.png");
        } else {
            loader.add("sky", "assets/img/level/sky.png");
            loader.add("mtnFar", "assets/img/level/mtn-far.png");
            loader.add("mtnMid", "assets/img/level/mtn-mid.png");
            loader.add("ground", "assets/img/level/ground.png");
            loader.add("clouds", "assets/img/level/clouds.png");
            loader.add("trees", "assets/img/level/trees.png");
            loader.add("grass", "assets/img/level/grass.png");
        }

        loader.once('complete', init);
        loader.load();
    }


    function createrenderer() {
        console.log("Create Renderer");

        var rendererOptions = {
            antialiasing: false,
            transparent: false,
            resolution: window.devicePixelRatio,
            autoResize: true,
        };

        // Create the canvas in which the game will show, and a
        // generic container for all the graphical objects
        renderer = PIXI.autoDetectRenderer(GAME_WIDTH, GAME_HEIGHT,
            rendererOptions);

        // Put the renderer on screen in the corner
        renderer.view.style.position = "absolute";
        renderer.view.style.top = "0px";
        renderer.view.style.left = "0px";

        // The stage is essentially a display list of all game objects
        // for Pixi to render; it's used in resize(), so it must exist
        stage = new PIXI.Container();

        // Size the renderer to fill the screen
        resize();

        // Actually place the renderer onto the page for display
        document.body.appendChild(renderer.view);

        // Listen for and adapt to changes to the screen size, e.g.,
        // user changing the window or rotating their device
        window.addEventListener("resize", resize);

        // Mod the title so it's easy to determine renderer on mobile
        if (renderer instanceof PIXI.WebGLRenderer) {
            document.title += " (WebGL)";
        } else {
            document.title += " (Canvas)";
        }

    }

    function init() {
        /*
         Layer order:
         sky | mtnFar | mtnMid | ground | clouds | trees | grass
         */

        sky =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.sky.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(sky);

        mtnFar =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.mtnFar.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(mtnFar);

        mtnMid =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.mtnMid.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(mtnMid);

        ground =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.ground.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(ground);

        clouds =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.clouds.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(clouds);

        trees =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.trees.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(trees);

        grass =
            new PIXI.extras.TilingSprite(PIXI.loader.resources.grass.texture,
                GAME_WIDTH, GAME_HEIGHT);
        stage.addChild(grass);

        // Prepare for first frame of game loop/animation
        lasttime = new Date().getTime();
        requestAnimationFrame(animate);

    }

    function resize() {

        // Determine which screen dimension is most constrained
        ratio = Math.min(window.innerWidth / GAME_WIDTH,
            window.innerHeight / GAME_HEIGHT);

        // Scale the view appropriately to fill that dimension
        stage.scale.x = stage.scale.y = ratio;

        // Update the renderer dimensions
        renderer.resize(Math.ceil(GAME_WIDTH * ratio),
            Math.ceil(GAME_HEIGHT * ratio));

        console.log("Resize\n" +
            "  Window inner " + window.innerWidth + "," +
            window.innerHeight +
            " pixel ratio " + window.devicePixelRatio + "\n" +
            "  Renderer " + renderer.width + "," +
            renderer.height + " res " + renderer.resolution + "\n" +
            "  Scale " + stage.scale.x + "," + stage.scale.y + "\n");

    }

    function animate() {

        // Determine seconds elapsed since last frame
        var currtime = new Date().getTime();
        var delta = (currtime - lasttime) / 1000;

        // Scroll the terrain
        mtnFar.tilePosition.x -= BG_RATE * delta + scrollSpeed.mtnFar;
        mtnMid.tilePosition.x -= BG_RATE * delta + scrollSpeed.mtnMid;
        clouds.tilePosition.x -= BG_RATE * delta + scrollSpeed.clouds;
        trees.tilePosition.x -= FG_RATE * delta + scrollSpeed.trees;
        grass.tilePosition.x -= BG_RATE * delta + scrollSpeed.grass;

        // Draw the stage and prepare for the next frame
        renderer.render(stage);
        requestAnimationFrame(animate);
        lasttime = currtime;

    }
</script>
</body>
</html>